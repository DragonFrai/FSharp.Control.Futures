Этот модуль во многом вдохновлен и адаптирован из реализации асинхронного рантайма проекта tokio.
Поэтому прежде всего хотелось бы их поблагодарить оставив ссылки.
(Вдруг Вы вдохновитесь прекрасной экосистемой tokio)

Сайт: https://tokio.rs/

GitHub: https://github.com/tokio-rs

Tokio runtime docs: https://docs.rs/tokio/latest/tokio/


# Высокоуровневые примитивы синхронизации основного модуля Future

В этом разделе рассматриваются существующие или планируемые типы из неймспейса
FSharp.Control.Futures.Sync и FSharp.Control.Futures.Mailbox


## Примитивы синхронизации модуля FSharp.Control.Futures.Sync

Примитивы синхронизации можно разделить на две условные группы:
"синхронизации исполнения" и "синхронизации данных"

### Примитивы "Синхронизации исполнения"

Представлены следующими типами:
- Semaphore
- Barrier
- Monitor
- WaitHandle

Они представляют собой асинхронные аналоги типов из стандартной библиотеки

### Примитивы "Синхронизации данных"

Представлены следующими типами:
- Mutex<'a>
- RwLock<'a>
- OnceCell<'a>

Эти типы защищают данные, предоставляя взможность менять их защищенно от остальных.

#### Mutex<'a>

Примитив синхронизации, защищающий разделяемые данные.
Мьютекс блокирует Future, ожидающие, пока общий ресурс станет доступным.

В асинхронном коде вполне нормально использовать обычный "Mutex" из стандартной библиотеки (Monitor или лок на объекте).

Функция, которую асинхронный мьютекс предлагает по сравнению с блокирующим мьютексом, —
это возможность удерживать его заблокированным в точке асинхронного ожидания (let! _).
Это делает асинхронный мьютекс более дорогим, чем блокирующий мьютекс,
поэтому блокирующий мьютекс должен быть предпочтительнее в тех случаях, когда его можно использовать
(Явные точки прерывания Future позволяют атомарно блокировать и изменять содержимое мьютекса).
Основной вариант использования асинхронного мьютекса —
предоставление общего изменяемого доступа к ресурсам ввода-вывода, таким как соединение с базой данных.
Если значение мьютекса — это просто данные, которые меняются мгновенно, не требуя асинхронных операций между блокировкой и освобождением, обычно уместно использовать блокирующий мьютекс.

Обратите внимание: Компилятор не запрещает сохранять блокировку Monitor, пока происходит асинхронная операция,
на практике это практически никогда не приводит к правильному параллельному коду, поскольку может легко привести к взаимоблокировкам.

Кроме того, если вам нужен общий доступ к ресурсу ввода-вывода,
часто лучше создать задачу для управления ресурсом ввода-вывода и использовать передачу сообщений для взаимодействия с этой задачей.

