# Детали реализации v0.1.*

## Тип `Future`

Для начала ознакомимся с базовыми типами

```fs
type Poll<'a> =
    | Ready of 'a
    | Pending

type Waker = unit -> unit

type Future<'a> = Future of (Waker -> Poll<'a>)
```

`Future<'a>` представляет собой мемоизированную "единицу вычисления". Или это можно назвать несбрасываемой машиной состояний, цель которой получить экземпляр `'a`.

Весь мeханизм организации асинхронного вычисления на основе `Future` сводится к *опросу* самой `Future` путём вызова \[*`Waker -> Poll<'a>`* (далее `poll`)\].

Результатом `poll` является текущее состояние `Future`, а именно *в процессе `Pending`* или *готово `Ready x`*.

В случае, если `Future` не совершает асинхронную работу и может сразу вернуть результат(возможно с некоторой работой), то при первом опросе должен возвращаться `Ready`. В противном случае `Future` должна запомнить переданный `Waker` и вызвать его в случае завершения асинхронной работы, чтобы планировщик *пробудил* её от ожидания этой работы.

> **Важно**: `Future` должна всегда *пробуждаться* через **последний** переданный ей `Waker`. Однако, она так же не должна опрашиваться повторно до вызова `Waker`'а.


## Ожидаемые инварианты
1. Вызов `poll` экземпляра `Future` всегда происходит одновременно не более одним потоком.
2. `Future` опрашивается повторно только после вызова последнего `Waker`'а, переданного ей.
3. > Этот инвариант в процессе обсуждения и может измениться, основным считать 3.1.

    3.1. `Future` может вызывать вызывать `Waker` несколько раз (но только последний извесный ей). Поэтому если `Future` выполняет 2 и более асинхронных работ параллельно, то на сохранённый `Waker` должна накладываться дополнительная синхронизация, в случае если он может вызываться несколько раз.

    3.2 `Future` может вызывать `Waker` только один раз (и только последний известный ей).
