# Детали реализации v0.5.\*

## Принцип работы типа `Future`

Весь мeханизм организации асинхронного вычисления на основе `Future` сводится к *опросу*
самой `Future` путём вызова \[*`Poll: Waker -> Poll<'a>`* (далее `poll`)\] до завершения её вычисления.

Результатом *опроса* является текущее состояние `Future`,
а именно *в процессе `Pending`* или *готово `Ready x`*.

В случае, если `Future` не совершает асинхронную работу и может сразу вернуть
результат(возможно с некоторой работой), то при первом опросе должен возвращаться `Ready`.
В противном случае `Future` должна запомнить последний переданный `Context` и вызвать его метод `Wake` в случае завершения
асинхронной работы, чтобы планировщик *пробудил* её от ожидания этой работы.

> При написании Future стоит учитывать, что пока в ней выполняются блокирующие
> операции -- блокируется поток планировщика, на котором она запушена.
> Для долгих блокирующих операций (когда это возможно, например, в циклах)
> можно применить `Future.yieldWorkflow`,
> который возвращает поток планировщику одноврменно с пробуждением `Future`.

> **Важно**: `Future` должна всегда *пробуждаться* через **последний** переданный ей `Context`.

## Ожидаемые инварианты
1. Вызов `poll` экземпляра `Future` всегда происходит одновременно не более одним потоком.
2. `Future` может *опрашиваться*, даже если она не *пробудилась*.
3. `Future` может несколько раз вызвать *пробуждаться* через `Context`.
4. `Cancel` для `Future` должен вызываться **не одновременно** с опросом
5. Повторная отмена `Future` -- UB
6. Опрос или пробуждение `Future` после её отмены -- UB
7. Отмену после получения результата следует игнорировать
8. `IPullStream` условно является подмножеством `Future`,
   поэтому инварианты `Future` верны и для `IPullStream`

> При опросе может возникнуть ситуация, когда вызвались и прошлый `oldCtx.Wake`, и текущий `ctx.Wake`,
> это стоит учитывать при написании планировщика
