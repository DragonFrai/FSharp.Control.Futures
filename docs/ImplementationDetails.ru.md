# Детали реализации v0.5.\*

## Принцип работы типа `Future`

Весь мeханизм организации асинхронного вычисления на основе `Future` сводится к *опросу*
самой `Future` путём вызова \[*`Poll: Waker -> Poll<'a>`* (далее `poll`)\] до завершения её вычисления.

Результатом *опроса* является текущее состояние `Future`,
а именно *в процессе `Pending`* или *готово `Ready x`*.

В случае, если `Future` не совершает асинхронную работу и может сразу вернуть
результат(возможно с некоторой работой), то при первом опросе должен возвращаться `Ready`.
В противном случае `Future` должна запомнить последний переданный `Waker` и вызвать его в случае завершения
асинхронной работы, чтобы планировщик *пробудил* её от ожидания этой работы.

> При написании Future стоит учитывать, что пока в ней выполняются блокирующие
> операции -- блокируется поток планировщика, на котором она запушена.
> Для долгих блокирующих операций (когда это позможно, например, в циклах)
> можно применить `Future.yieldWorkflow`,
> который возвращает поток планировщику одноврменно с пробуждением `Future`.

> **Важно**: `Future` должна всегда *пробуждаться* через **последний** переданный ей `Waker`.

## Ожидаемые инварианты
1. Вызов `poll` экземпляра `Future` всегда происходит одновременно не более одним потоком.
2. `Future` может *опрашиваться*, даже если `Waker` не был вызван.
3. `Future` может несколько раз вызвать `Waker` до пробуждения.

> При опросе может возникнуть ситуация, когда вызвались и прошлый `Waker`, и текущий `Waker`,
> это стоит учитывать при написании планировщика
