# Детали реализации

Дизайн данной библиотеки вдохновлен дизайном `Future` из языка Rust.
Однако сейчас содержит некоторые значимые изменения.

## Принцип работы типа `Future`

Весь мeханизм организации асинхронного вычисления на основе `Future` сводится к *опросу*
самой `Future` путём вызова *`Poll: IContext -> Poll<'a>`* до завершения её вычисления.
`Future` может быть отменена вызовом `Future.Cancel: unit -> unit`

Результатом *опроса* является текущее состояние вычисления `Future`:
1. `Pending` - вычисление `Future` находится в процессе и еще не завершено.
2. `Ready x` - значение вычислено и опрос больше не требуется.
3. `Transit fut` - говорит о подмене текущей `Future` другой такого же типа.
   Уменьшает глубину опроса и предназначен для оптимизации bind выражаемых конструкций.

Если `Future` не совершает асинхронную работу и может сразу вернуть
результат(возможно с некоторой работой), то при первом опросе должен возвращаться `Ready`.
В противном случае `Future` должна запомнить последний переданный `Context` и вызвать его метод `Wake`
в случае завершения асинхронной работы, чтобы планировщик *пробудил* её от ожидания этой работы.

> При написании Future стоит учитывать, что пока в ней выполняются блокирующие
> операции -- блокируется поток планировщика, на котором она запушена.
> Для долгих блокирующих операций (когда это возможно, например, в циклах которые сами не возвращают управление)
> можно применить `Future.yieldWorkflow`, который возвращает поток планировщику одновременно с пробуждением `Future`.

Дизайн *отмены* `Future` прокидывает отмену ко всем дочерним `Future` независимо от способа их создания.
Это позволяет *отменять* запущенную на планировщие `Future` через `IJoinHandle` (который может быть преобразован в `Future`).
А также *отменять* любую `Future` в альтернативах (например внутри `Future.first`).

## Ожидаемые инварианты Future
- `Future` полностью синхронна. Методы `Poll` и `Cancel` не потоко-безопасны.
- `Future` считается терминальной и не должна *опрашиваться*, *отменяться* или *пробуждаться* после:
  * Вызова `Poll` с результатом `Ready x`, `Transit fut`
    или выбросом исключения (что считается эквивалентом `Ready (Error exn)`)
  * Вызова `Cancel`
- `Future` может *опрашиваться* повторно, даже если она не *пробудилась*.
- `Future` может *пробуждаться* несколько раз до повторного *опроса*.
- Контекст для `Future` должен быть одним и тем же от первого опроса, до `Ready x`.
  `Future` достаточно сохранить контекст при первом опросе и не перезаписывать его.
  Можно сказать, что каждый контекст соответствует одному запуску.
- При сохраненном контексте, *пробуждение* не происходит при вызове `Cancel`.
  Т.е. при вызове `Poll` и `Cancel` подряд, последний должен стереть контекст, но не *пробуждать* `Future`

## Рекомендации
- *Отмене* не стоит бросать исключения (кроме случаев нарушения инвариантов `Future`).
   Если *отмена* не поддерживается, стоит просто не вызывать Wake по завершении работы.

## Примечания

> Для реализаций `Future` любое поведение не следующее инвариантам -- UB,
> и может как обрабатываться особым способом, так и игнорироваться.

> `IStream` по сути является расширением модели `Future`,
поэтому инварианты `Future` как правило верны и для `IStream`

> В отличие от реализации в Rust, я не заставляю Future обновлять последний сохраненный ею
> IContext при каждом опросе. Преимущества на обоих платформах мне не очевидны, а это ощутимо усложняет реализацию.
> Поэтому это может измениться в будущем.

> Методы `Future` не предназначены для ручного вызова, т.к. требуют с собой деликатного обращения.
> По этой причине `IJoingHandle` не наследует `Future`, а имеет отображение в неё

> Каждая `Future` может быть использована как-либо (забайнджена, запихнула в комбинатор, запущена)
> только ОДИН раз

> Есть некоторая коллизия с тем, что Future может выкидывать исключения исключения как предметные, так и свои.
> Например, неявным результатом IVar может быть любое исключение. И одно из них это FutureTerminatedException.
> В этой точке будет не так прозрачно, исключение произошло в читающей Future или в записывающей.
> Но
> 0. Исключениям можно, у них сложный переезд из места появление в абсолютно случайное
> 1. Возможные решения слишком муторные и не стоят того из-за исключения, которое означает проблему в библиотечном, а не пользовательском коде
