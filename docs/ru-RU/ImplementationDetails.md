# Детали реализации

## Принцип работы типа `Future`

Весь мeханизм организации асинхронного вычисления на основе `Future` сводится к *опросу*
самой `Future` путём вызова *`Poll: IContext -> Poll<'a>`* до завершения её вычисления.
`Future` может быть отменена вызовом `Future.Cancel: unit -> unit`

Результатом *опроса* является текущее состояние вычисления `Future`:
1. `Pending` - вычисление `Future` находится в процессе и еще не завершено.
2. `Ready x` - значение вычислено и опрос больше не требуется.
3. `Transit fut` - говорит о подмене текущей `Future` другой такого же типа.
   Уменьшает глубину опроса и предназначен для оптимизации bind выражаемых конструкций.

Если `Future` не совершает асинхронную работу и может сразу вернуть
результат(возможно с некоторой работой), то при первом опросе должен возвращаться `Ready`.
В противном случае `Future` должна запомнить последний переданный `Context` и вызвать его метод `Wake`
в случае завершения асинхронной работы, чтобы планировщик *пробудил* её от ожидания этой работы.

> При написании Future стоит учитывать, что пока в ней выполняются блокирующие
> операции -- блокируется поток планировщика, на котором она запушена.
> Для долгих блокирующих операций (когда это возможно, например, в циклах которые сами не возвращают управление)
> можно применить `Future.yieldWorkflow`, который возвращает поток планировщику одновременно с пробуждением `Future`.

Дизайн *отмены* `Future` прокидывает отмену ко всем дочерним `Future` независимо от способа их создания.
Это позволяет *отменять* запущенную на планировщие `Future` через `IJoinHandle` (который может быть преобразован в `Future`).
А также *отменять* любую `Future` в альтернативах (например внутри `Future.first`).

## Ожидаемые инварианты Future
1. `Future` полностью синхронна. Методы `Poll` и `Cancel` не потоко-безопасны.
2. `Ready` и `Transit fut` состояния являются терминальными.
   После их возврата, `Future` вернувшая их не должна опрашиваться.
3. `Future` может *опрашиваться* повторно, даже если она не *пробудилась*.
4. `Future` может *пробуждаться* несколько раз до повторного *опроса*.
5. *Отмена* может быть вызвана в запуска и в процессе работы. Терминальные футуры не должны никак использоваться.
6. `Future` не может *опрашиваться* после отмены.
7. `Future` не может *пробуждаться* после отмены.
8. \* Контекст для `Future` должен быть одним и тем же от первого опроса, до Ready x.
    `Future` достаточно сохранить контекст при первом опросе и не перезаписывать его.
9. Контекст не должен реагировать на `Wake` если `Future` уже отменена

## Рекомендации
- *Отмене* не стоит бросать исключения (кроме случаев нарушения инвариантов `Future`).
   Если *отмена* не поддерживается, стоит просто игнорировать запрос на отмену.
- Если Future бросает при Poll исключение, ей следует переходить в
   терминальное состояние, как если бы возвращала `Ready (Error x)`

## Примечания

> Для реализаций `Future` любое поведение не следующее инвариантам -- UB,
> и может как обрабатываться особым способом, так и игнорироваться.

> `IStream` по сути является расширением модели `Future`,
поэтому инварианты `Future` как правило верны и для `IStream`

> В отличие от реализации в Rust, я не заставляю Future обновлять последний сохраненный ею
> IContext при каждом опросе. Преимущества на обоих платформах мне не очевидны, а это ощутимо усложняет реализацию.
> Поэтому это может измениться в будущем.

