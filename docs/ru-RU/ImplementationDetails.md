# Детали реализации v0.5.\*

## Принцип работы типа `Future`

Весь мeханизм организации асинхронного вычисления на основе `Future` сводится к *опросу*
самой `Future` путём вызова \[*`Poll: Context -> Poll<'a>`* (далее `poll`)\] до завершения её вычисления.
`Future` может быть отменена вызовом `Future.Cancel: unit -> unit`

Результатом *опроса* является текущее состояние `Future`,
а именно *в процессе `Pending`* или *готово `Ready x`*.

В случае, если `Future` не совершает асинхронную работу и может сразу вернуть
результат(возможно с некоторой работой), то при первом опросе должен возвращаться `Ready`.
В противном случае `Future` должна запомнить последний переданный `Context` и вызвать его метод `Wake` в случае завершения
асинхронной работы, чтобы планировщик *пробудил* её от ожидания этой работы.

> При написании Future стоит учитывать, что пока в ней выполняются блокирующие
> операции -- блокируется поток планировщика, на котором она запушена.
> Для долгих блокирующих операций (когда это возможно, например, в циклах)
> можно применить `Future.yieldWorkflow`,
> который возвращает поток планировщику одновременно с пробуждением `Future`.

> **Важно**: Контекст для `Future` должен быть одним и тем же от первого опроса, да Ready x

## Ожидаемые инварианты Future
1. Вызов `Poll` и `Cancel` (в том числе вместе)
   всегда происходит одновременно не более одним потоком.
2. `Future` может *опрашиваться* повторно, даже если она не *пробудилась*.
3. `Future` может несколько раз *пробуждаться* несколько раз до повторного *опроса*.

4. Повторная отмена `Future` -- UB
5. Опрос или пробуждение `Future` после её отмены -- UB
6. Отмену после получения результата следует игнорировать

> `IPullStream` условно является расширением модели `Future`,
   поэтому инварианты `Future` как правило верны и для `IPullStream`


