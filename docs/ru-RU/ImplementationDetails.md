# Детали реализации

## Принцип работы типа `Future`

Весь мeханизм организации асинхронного вычисления на основе `Future` сводится к *опросу*
самой `Future` путём вызова *`Poll: Context -> Poll<'a>`* до завершения её вычисления.
`Future` может быть отменена вызовом `Future.Cancel: unit -> unit`

Результатом *опроса* является текущее состояние вычисления `Future`:
1. `Pending` - вычисление `Future` находится в процессе и еще не завершено.
2. `Ready x` - значение вычислено и опрос больше не требуется.
3. `Transit fut` - говорит о подмене текущей `Future` другой такого же типа.
   Уменьшает глубину опроса и предназначен для оптимизации bind выражаемых конструкций.

Если `Future` не совершает асинхронную работу и может сразу вернуть
результат(возможно с некоторой работой), то при первом опросе должен возвращаться `Ready`.
В противном случае `Future` должна запомнить последний переданный `Context` и вызвать его метод `Wake`
в случае завершения асинхронной работы, чтобы планировщик *пробудил* её от ожидания этой работы.

> При написании Future стоит учитывать, что пока в ней выполняются блокирующие
> операции -- блокируется поток планировщика, на котором она запушена.
> Для долгих блокирующих операций (когда это возможно, например, в циклах которые сами не возвращают управление)
> можно применить `Future.yieldWorkflow`, который возвращает поток планировщику одновременно с пробуждением `Future`.

Дизайн *отмены* `Future` прокидывает отмену ко всем дочерним `Future` независимо от способа их создания.
Это позволяет *отменять* запущенную на планировщие `Future` через `IJoinHandle` (который также является `Future`).
А также *отменять* любую `Future` в альтернативах (например внутри `Future.first`).


## Ожидаемые инварианты Future
1. Вызов `Poll` или `Cancel` не должен происходить одновременно из разных потоков.
   То есть совокупность этих методов не являются потоко-безопасной.
2. `Ready` и `Transit fut` состояния являются терминальными.
   После их возврата, `Future` вернувшая их не должна опрашиваться.
3. `Future` может *опрашиваться* повторно, даже если она не *пробудилась*.
4. `Future` может *пробуждаться* несколько раз до повторного *опроса*.
5. *Отмена* может быть вызвана в любой момент: до запуска, в процессе работы или после получения результата.
6. *Отмена* не должна бросать исключения (кроме случаев нарушения инвариантов `Future`).
   Если *отмена* не поддерживается, стоит просто игнорировать запрос на отмену.
7. `Future` не может *отменяться* повторно.
8. `Future` не может *опрашиваться* после отмены.
9. `Future` не может *пробуждаться* после отмены.
10. Контекст для `Future` должен быть одним и тем же от первого опроса, до Ready x.
    `Future` достаточно сохранить контекст при первом опросе и не перезаписывать его.

> Для реализаций `Future` любое поведение не следующее инвариантам -- UB,
> и может как обрабатываться особым способом, так и игнорироваться.

> `IStream` условно является расширением модели `Future`,
поэтому инварианты `Future` как правило верны и для `IStream`
